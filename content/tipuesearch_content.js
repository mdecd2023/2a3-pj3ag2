var tipuesearch = {"pages": [{'title': 'About', 'text': '成員: \n 41023103: http://[2001:288:6004:17:2023:cda:2:1]:23020/ \n 41023106: http://[2001:288:6004:17:2023:cda:2:2]:23020/ \n 41023113: http://[2001:288:6004:17:2023:cda:2:3]:23020/ \n 41023116: http://[2001:288:6004:17:2023:cda:2:4]:23020/ \n 組長:41023125: http://[2001:288:6004:17:2023:cda:2:5]:23020/ \n 41023132: http://[2001:288:6004:17:2023:cda:2:6]:23020/ \n 41023151: http://[2001:288:6004:17:2023:cda:2:7]:23020/ \n 41023153: http://[2001:288:6004:17:2023:cda:2:8]:23020/ \n \n 3ag2倉儲:  https://github.com/mdecd2023/2a3-pj3ag2 \xa0 \n \n 3ag2網站:  https://mdecd2023.github.io/2a3-pj3ag2 \xa0\xa0 \n \n \n \n \n', 'tags': '', 'url': 'About.html'}, {'title': 'pj3', 'text': 'cd_report.pdf \n Source code (zip) \n 2a3-pj3ag2.pptx \n 分配表 \n 1.球場繪製:41023106 \n 2.球員繪製、感測器建立、Latex報告撰寫:41023113 \n 3.記分板繪製:41023153 \n 4.自動控制程式:41023125 \n 5.影片 、 ppt 、網頁整理 :41023116、41023151 \n 6.note:41023103 \n \n 場景模擬 \n \n 我們的可愛車車球場 \n \n 球員場景建立 \n 使用onshape繪製球員，後匯入Coppeliasim進行爆炸拆件，拆件後加入joint並且將物件改為實體。 \n 圖檔匯入 Coppeliasim步驟:  File-Import-Mseh -選擇圖檔匯入 \n 爆炸拆件:右鍵點選本體- Edit-Grouping/Merging-Divide seleceted shapes \n 將物件改為實體: 點選本體旁圖示-Show dynamic properties dialog-勾選Body is respondable以及Body is dynamic \n 加入joint:滑鼠右鍵- Add-Joint-Revolute \n \n 球員 \n 下圖為第一版球員,選擇較為酷炫的跑車外型。 \n \n 做動影片   \n 開會紀錄: \n 討論分工及場景建置 \n 協同工作並一起解決問題。 \n 由於尺寸錯誤，因此縮小比例製作了第二版。 \n CAR2.ttt \n \n 1.ttt \n 計分器 \n 在計分器設計上，採用齒輪傳動方式，帶動數字轉盤，能夠準確的調整分數。 \n \n \n 計分.ttt \n 球場 \n 我們的球場以足球場做為參考,將中場,禁區,點球罰球區做出來 \n pj3球場.SLDPRT \n pj3球場.STL \n \n \n \n 改版 \n pj3球場v2 \n pj3球場v2. \xa0 \n \n \n 球場.ttt \n 加入計時器球員等零件,且每位球員都有屬於自己的編號以便於分辨自己操控哪隻球員。 \n \n \n 計時器模擬影片 \n \n 計分器建立影片 \n \n 最後修改樣式 \n 最後修改樣式.ttt \n \n', 'tags': '', 'url': 'pj3.html'}, {'title': '機械計分繪製', 'text': '我們參考onshape公開資料庫的機械計分器，並將其改造為我們所需之樣式 \n \n 成品圖 \n \n 製作過程: \n 首先製作第一顆齒輪(主動) \n 採用齒數:10、模數:2.1mm、節圓直徑21.1mm、壓力角:20度、根圓角(漸開線 圓柱齒輪齒根過渡曲線及其圓角半徑大小 ):1/3、孔徑7mm、厚度:9mm \n (根圓角用途: 實際生產中有時為 增大齒輪的齒根圓角以提高齒輪輪齒的抗彎強度 而相應地增大刀具的齒頂圓角,也有時為改善刀具齒頂的磨損條件而增大刀具齒頂圓角 ) \n \n 複製平移X方向-19mm當作十位數齒輪的帶動輪。 \n \n 加入兩顆齒輪的軸 \n \n 製作第二顆齒輪 \n 同樣採用 齒數:10、模數:2.1mm、節圓直徑21.1mm、壓力角:20度、根圓角(漸開線 圓柱齒輪齒根過渡曲線及其圓角半徑大小 ):1/3、孔徑7mm、深度改為:4.5mm \n \n \n 將齒輪平移X方向-19mm \n \n 加入記分板的分數顯示器 \n \n 加入帶動十位數轉盤的齒輪(該齒輪作用為該轉盤到達0帶動十位數轉盤，將十位數轉盤轉為顯示1) \n \n 因為必須在到達0時才帶動另一顆齒輪，所以須將多餘的齒除料。 \n \n 將計分顯示器平移，作為十位數顯示器 \n \n 加入軸 \n \n 為了於Coppeliasim明顯的顯示數字，必須將數字獨立出來作為一個零件並對其改色。 \n \n 匯入Coppeliasim進行內部設置 \n 加入joint並且將數字換成明顯的顏色 \n \n 加上外蓋並加入區分紅隊跟藍隊的標示 \n \n \n 計分器建立影片 \n', 'tags': '', 'url': '機械計分繪製.html'}, {'title': '程式', 'text': '記分板測試 \n local joints = {{},{},{},{}}\nlocal angle = {0,0,0,0}\nfunction sysCall_init()\n    -- do some initialization here\n      for i = 1, 4 do\n        joint = sim.getObject(\'/joint\' .. i)\n        joints[i] = joint\n        --print(joints)\n    end\nend\n\nfunction sysCall_actuation()\n    -- put your actuation code here\n    for i = 1, 4 do\n    sim.setJointTargetPosition(joints[i], angle[i])\n    a = angle[i]\n    angle[i] = a + 36\n    end \n    \n    \nend\n\nfunction sysCall_sensing()\n    -- put your sensing code here\n    --\nend\n\nfunction sysCall_cleanup()\n    -- do some clean-up here\nend\n\n-- See the user manual or the available code snippets for additional callback functions and details\n \n \n 記分板連動 \n local joints = {{},{},{},{}}\nlocal sensors = {{},{},{},{},{},{}}\nlocal socoresensors = {{},{}}\nlocal angle = {0,0,0,0}\nlocal initPosition = {}\nlocal initPosition = {}\nfunction regress()\n    --sim.pauseSimulation()\n    --sim.setObjectPosition(bubbleRobBase, -1, initialBubbleRobPosition)\n    --sim.setObjectOrientation(bubbleRobBase, -1, initialBubbleRobOrientation)\n    sim.setObjectPosition(ball, -1, initPosition)\n    sim.setObjectOrientation(ball, -1, initPosition)\n    --sim.setObjectPosition(23, -1, initia)\n    --sim.setObjectOrientation(23, -1, initial)\nend\nfunction sysCall_init()\n    -- do some initialization here\n    for i = 1, 4 do\n        joint = sim.getObject(\'/box/joint\' .. i)\n\n        joints[i] = joint\n        --print(joints)\n    end\n    for i = 0, 5 do\n        sensor =  sim.getObject(\'/Proximity_sensor[\' .. i ..\']\')\n        sensors[i+1] = sensor\n    end\n    --print(sensors)\n    for i = 0, 1 do\n        socoresensor =  sim.getObject(\'/Shape[0]/Proximity_sensor[\' .. i ..\']\')\n        socoresensors[i+1] = socoresensor\n    end\n    ball = sim.getObject(\'/Capsule\')\n    initPosition = sim.getObjectPosition(ball, -1)\n    initialballOrientation = sim.getObjectOrientation(ball, -1)\n    print(initPosition)\nend\n \nfunction sysCall_actuation()\n    -- put your actuation code here\n    \n    for i = 0, 5 do\n        result=sim.readProximitySensor(sensors[i+1])\n        --result=sim.readProximitySensor(sensors[1])\n        if(result>0)then\n            sim.stopSimulation()\n        end\n        --print(result)\n    end\n    scoreresult1=sim.readProximitySensor(socoresensors[1])\n    if(scoreresult1>0) then\n        angle[3] = angle[3] + 1 \n        if angle[3] == 10 then\n            angle[3] = 0 \n            angle[4] = angle[4] + 1\n        end\n        --sim.stopSimulation()\n        regress()\n    end\n    scoreresult2=sim.readProximitySensor(socoresensors[2])\n    if(scoreresult2>0)then\n        angle[1] = angle[1] + 1 \n        if angle[1] == 10 then\n            angle[1] = 0 \n            angle[2] = angle[2] + 1\n        end\n        --sim.stopSimulation()\n        regress()\n\n    end\n    for i = 1, 4 do\n        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)\n        --a = angle[i]\n        --angle[i] = a + 1\n    end \n end\n \n \n 記分板程式整理 \n local joints = {{},{},{},{}}\nlocal sensors = {{},{},{},{},{},{}}\nlocal socoresensors = {{},{}}\nlocal angle = {0,0,0,0}\nlocal initPosition = {}\nlocal initOrientation = {}\nfunction regress(team)\n    --sim.pauseSimulation()\n    sim.setObjectPosition(ball, -1, initPosition)\n    sim.setObjectOrientation(ball, -1, initOrientation)\n    angle[team+1] = angle[team+1] + 1 \n    if angle[team+1] == 10 and team == 2 or 0 then\n        angle[team+1] = 0 \n        angle[team+2] = angle[team+2] + 1\n    end\nend\nfunction sysCall_init()\n    for i = 1, 4 do\n        joint = sim.getObject(\'/box/joint\' .. i)\n        joints[i] = joint\n    end\n    for i = 0, 5 do\n        sensor =  sim.getObject(\'/Proximity_sensor[\' .. i ..\']\')\n        sensors[i+1] = sensor\n    end\n    for i = 0, 1 do\n        socoresensor =  sim.getObject(\'/Shape[0]/Proximity_sensor[\' .. i ..\']\')\n        socoresensors[i+1] = socoresensor\n    end\n    ball = sim.getObject(\'/Capsule\')\n    initPosition = sim.getObjectPosition(ball, -1)\n    initOrientation = sim.getObjectOrientation(ball, -1)\n    print(initPosition)\nend\n  \nfunction sysCall_actuation()\n    for i = 0, 5 do\n        result=sim.readProximitySensor(sensors[i+1])\n        if(result>0)then\n        end\n    end\n    scoreresult1=sim.readProximitySensor(socoresensors[1])\n    scoreresult2=sim.readProximitySensor(socoresensors[2])\n    if(scoreresult1>0) then\n        regress(0)\n    end\n    if(scoreresult2>0)then\n        regress(2)\n    end\n    for i = 1, 4 do\n        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)\n    end \n end \n \n \n BubbleRob觸發感測器歸位 \n local joints = {{},{},{},{}}\nlocal sensors = {{},{},{},{},{},{}}\nlocal socoresensors = {{},{}}\nlocal angle = {0,0,0,0}\nlocal initPosition = {}\nlocal initOrientation = {}\nlocal BubbleRobs = {}\nfunction regress(team)\n    --sim.pauseSimulation()\n    for i = 1,8 do\n        sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n        sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n    end\n    angle[team+1] = angle[team+1] + 1 \n    if angle[team+1] == 10  then\n        angle[team+1] = 0 \n        angle[team+2] = angle[team+2] + 1\n    end\nend\nfunction sysCall_init()\n    for i = 1, 4 do\n        joint = sim.getObject(\'/box/joint\' .. i)\n        joints[i] = joint\n    end\n    for i = 0, 5 do\n        sensor =  sim.getObject(\'/Proximity_sensor[\' .. i ..\']\')\n        sensors[i+1] = sensor\n    end\n    for i = 0, 1 do\n        socoresensor =  sim.getObject(\'/Shape[0]/Proximity_sensor[\' .. i ..\']\')\n        socoresensors[i+1] = socoresensor\n        \n    end\n    --ball = sim.getObject(\'/Capsule\')\n    --initPosition = sim.getObjectPosition(ball, -1)\n    --initOrientation = sim.getObjectOrientation(ball, -1)\n    for i = 1,8 do\n        BubbleRob = sim.getObject(\'/Shape[\'..i+2 .. \']\')\n        BubbleRobs[i] = BubbleRob\n        initPosition[i] = sim.getObjectPosition(BubbleRob, -1)\n        initOrientation[i] = sim.getObjectOrientation(BubbleRob, -1)\n    end\nend\n  \nfunction sysCall_actuation()\n    for i = 0, 5 do\n        result=sim.readProximitySensor(sensors[i+1])\n        if(result>0)then\n            for i = 1,8 do\n                sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n                sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n            end\n        end\n    end\n    scoreresult1=sim.readProximitySensor(socoresensors[1])\n    scoreresult2=sim.readProximitySensor(socoresensors[2])\n    if(scoreresult1>0) then\n        regress(0)\n    end\n    if(scoreresult2>0)then\n        regress(2)\n    end\n    for i = 1, 4 do\n        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)\n    end \n end \n ball隨機位置出現 \n local joints = {{},{},{},{}}\nlocal sensors = {{},{},{},{},{},{}}\nlocal socoresensors = {{},{}}\nlocal angle = {0,0,0,0}\nlocal initPosition = {}\nlocal initOrientation = {}\nlocal BubbleRobs = {}\nfunction randomNumber()\n    math.randomseed(os.time())\n    return {tonumber(math.random(-1, 1) .. \'.\' .. math.random(0,9)),tonumber(0 .. \'.\' .. math.random(0,9)),0.2}\nend\nfunction regress(team)\n    --sim.pauseSimulation()\n    for i = 1,8 do\n        sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n        sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n    end\n    sim.setObjectPosition(ball, -1, randomNumber())\n    angle[team+1] = angle[team+1] + 1 \n    if angle[team+1] == 10  then\n        angle[team+1] = 0 \n        angle[team+2] = angle[team+2] + 1\n    end\nend\nfunction sysCall_init()\n    ball = sim.getObject(\'/Capsule\')\n    for i = 1, 4 do\n        joint = sim.getObject(\'/box/joint\' .. i)\n        joints[i] = joint\n    end\n    for i = 0, 5 do\n        sensor =  sim.getObject(\'/Proximity_sensor[\' .. i ..\']\')\n        sensors[i+1] = sensor\n    end\n    for i = 0, 1 do\n        socoresensor =  sim.getObject(\'/Shape[0]/Proximity_sensor[\' .. i ..\']\')\n        socoresensors[i+1] = socoresensor\n        \n    end\n    for i = 1,8 do\n        BubbleRob = sim.getObject(\'/Shape[\'..i+2 .. \']\')\n        BubbleRobs[i] = BubbleRob\n        initPosition[i] = sim.getObjectPosition(BubbleRob, -1)\n        initOrientation[i] = sim.getObjectOrientation(BubbleRob, -1)\n    end\nend\n  \nfunction sysCall_actuation()\n    scoreresult1=sim.readProximitySensor(socoresensors[1])\n    scoreresult2=sim.readProximitySensor(socoresensors[2])\n    for i = 0, 5 do\n        result=sim.readProximitySensor(sensors[i+1])\n        if(result>0)then\n            for i = 1,8 do\n                sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n                sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n                sim.setObjectPosition(ball, -1, randomNumber())\n            end\n        end\n    end\n    if(scoreresult1>0) then\n        regress(0)\n    end\n    if(scoreresult2>0)then\n        regress(2)\n    end\n    for i = 1, 4 do\n        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)\n    end \n end \n 加入LED記分板 \n local joints = {{},{},{},{}}\nlocal sensors = {{},{},{},{},{},{}}\nlocal socoresensors = {{},{}}\nlocal angle = {0,0,0,0}\nlocal initPosition = {}\nlocal initOrientation = {}\nlocal BubbleRobs = {}\nlocal handles = {{},{},{},{}}\nlocal serialNumber = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\',\'g\'}\nlocal colors = {{1,0.09,1},{0,0,1},{0,1,1}}\nlocal specialNumbers = {{2, 3},{1,2,4,5,7},{1,2,3,4,7},{2,3,6,7},{1,3,4,6,7},{1,3,4,5,6,7},{1,2,3,6},{1,2,3,4,5,6,7},{1,2,3,4,6,7}}\nspecialNumbers[0] = {1,2,3,4,5,6}\nfunction Number(displayNumber,ser,color)\n    for i = 1, 7 do\n        for j = 1, #specialNumbers[ser] do\n            if i == specialNumbers[ser][j] then\n                sim.setShapeColor(handles[displayNumber][i], nil, sim.colorcomponent_ambient_diffuse, colors[color])\n                break\n            end\n        end\n    end\nend\nfunction scoreboard(number)\n    local numberString = tostring(number)\n    if #numberString < 2 then\n        numberString = \'0\' .. numberString\n    end\n    local tensDigit = tonumber(numberString:sub(1, 1))\n    local onesDigit = tonumber(numberString:sub(2, 2))\n    return{tensDigit,onesDigit}\nend\nfunction Toclear()\n    for i = 1, 7 do\n        for x = 1, 4 do\n            handle = handles[x][i]\n            sim.setShapeColor(handle, nil, sim.colorcomponent_ambient_diffuse, colors[3])\n        end\n    end\nend\nfunction randomNumber()\n    math.randomseed(os.time())\n    return {tonumber(math.random(-1, 1) .. \'.\' .. math.random(0,9)),tonumber(0 .. \'.\' .. math.random(0,9)),0.2}\nend\nfunction regress(team)\n    --sim.pauseSimulation()\n    for i = 1,8 do\n        sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n        sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n    end\n    sim.setObjectPosition(ball, -1, randomNumber())\n    angle[team+1] = angle[team+1] + 1 \n    if angle[team+1] == 10  then\n        angle[team+1] = 0 \n        angle[team+2] = angle[team+2] + 1\n    end\nend\nfunction sysCall_init()\n    score1 = 0\n    score2 = 0 \n    ball = sim.getObject(\'/Capsule\')\n    for i = 1, 4 do\n        joint = sim.getObject(\'/box/joint\' .. i)\n        joints[i] = joint\n    end\n    for i = 0, 5 do\n        sensor =  sim.getObject(\'/Proximity_sensor[\' .. i ..\']\')\n        sensors[i+1] = sensor\n    end\n    for i = 0, 1 do\n        socoresensor =  sim.getObject(\'/Shape[0]/Proximity_sensor[\' .. i ..\']\')\n        socoresensors[i+1] = socoresensor\n        \n    end\n    for i = 1,8 do\n        BubbleRob = sim.getObject(\'/Shape[\'..i+2 .. \']\')\n        BubbleRobs[i] = BubbleRob\n        initPosition[i] = sim.getObjectPosition(BubbleRob, -1)\n        initOrientation[i] = sim.getObjectOrientation(BubbleRob, -1)\n    end\n    for i = 1, 7 do\n        for x = 1, 4 do\n            ii = tostring(x) .. serialNumber[i]\n            local handle = sim.getObjectHandle("/scoreboard/".. ii )\n            handles[x][i] = handle\n        end\n    end\nend\n  \nfunction sysCall_actuation()\n    scoreresult1=sim.readProximitySensor(socoresensors[1])\n    scoreresult2=sim.readProximitySensor(socoresensors[2])\n    for i = 0, 5 do\n        result=sim.readProximitySensor(sensors[i+1])\n        if(result>0)then\n            for i = 1,8 do\n                sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n                sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n                sim.setObjectPosition(ball, -1, randomNumber())\n            end\n        end\n    end\n    if(scoreresult1>0) then\n        regress(0)\n        score2 = score2+1\n    end\n    if(scoreresult2>0)then\n        regress(2)\n        score1 = score1+1\n    end\n    for i = 1, 4 do\n        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)\n    end \n    pink = scoreboard(score1)\n    blue = scoreboard(score2)\n    Toclear()\n    for i = 1, 2 do\n        Number(i,pink[i],1)\n        --Number(i,0)\n        Number(i+2,blue[i],2)\n    end\n end\n function sysCall_cleanup()\n    Toclear()\nend \n 加入計時器 \n local joints = {{},{},{},{}}\nlocal sensors = {{},{},{},{},{},{}}\nlocal socoresensors = {{},{}}\nlocal angle = {0,0,0,0}\nlocal initPosition = {}\nlocal initOrientation = {}\nlocal BubbleRobs = {}\nlocal handles = {{},{},{},{}}\nlocal serialNumber = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\',\'g\'}\nlocal colors = {{1,0.09,1},{0,0,1},{0,1,1}}\nlocal specialNumbers = {{2, 3},{1,2,4,5,7},{1,2,3,4,7},{2,3,6,7},{1,3,4,6,7},{1,3,4,5,6,7},{1,2,3,6},{1,2,3,4,5,6,7},{1,2,3,4,6,7}}\nspecialNumbers[0] = {1,2,3,4,5,6}\nfunction Number(displayNumber,ser,color)\n    for i = 1, 7 do\n        for j = 1, #specialNumbers[ser] do\n            if i == specialNumbers[ser][j] then\n                sim.setShapeColor(handles[displayNumber][i], nil, sim.colorcomponent_ambient_diffuse, colors[color])\n                break\n            end\n        end\n    end\nend\nfunction scoreboard(number)\n    local numberString = tostring(number)\n    if #numberString < 2 then\n        numberString = \'0\' .. numberString\n    end\n    local tensDigit = tonumber(numberString:sub(1, 1))\n    local onesDigit = tonumber(numberString:sub(2, 2))\n    return{tensDigit,onesDigit}\nend\nfunction Toclear()\n    for i = 1, 7 do\n        for x = 1, 4 do\n            handle = handles[x][i]\n            sim.setShapeColor(handle, nil, sim.colorcomponent_ambient_diffuse, colors[3])\n        end\n    end\nend\nfunction randomNumber()\n    math.randomseed(os.time())\n    return {tonumber(math.random(-1, 1) .. \'.\' .. math.random(0,9)),tonumber(0 .. \'.\' .. math.random(0,9)),0.2}\nend\nfunction regress(team)\n    --sim.pauseSimulation()\n    for i = 1,8 do\n        sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n        sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n    end\n    sim.setObjectPosition(ball, -1, randomNumber())\n    angle[team+1] = angle[team+1] + 1 \n    if angle[team+1] == 10  then\n        angle[team+1] = 0 \n        angle[team+2] = angle[team+2] + 1\n    end\nend\nfunction sysCall_init()\n    count = 18000\n    score1 = 0\n    score2 = 0 \n    ball = sim.getObject(\'/Capsule\')\n    for i = 1, 4 do\n        joint = sim.getObject(\'/box/joint\' .. i)\n        joints[i] = joint\n    end\n    for i = 0, 5 do\n        sensor =  sim.getObject(\'/Proximity_sensor[\' .. i ..\']\')\n        sensors[i+1] = sensor\n    end\n    for i = 0, 1 do\n        socoresensor =  sim.getObject(\'/Shape[0]/Proximity_sensor[\' .. i ..\']\')\n        socoresensors[i+1] = socoresensor\n        \n    end\n    for i = 1,8 do\n        BubbleRob = sim.getObject(\'/Shape[\'..i+2 .. \']\')\n        BubbleRobs[i] = BubbleRob\n        initPosition[i] = sim.getObjectPosition(BubbleRob, -1)\n        initOrientation[i] = sim.getObjectOrientation(BubbleRob, -1)\n    end\n    for i = 1, 7 do\n        for x = 1, 4 do\n            ii = tostring(x) .. serialNumber[i]\n            local handle = sim.getObjectHandle("/scoreboard/".. ii )\n            handles[x][i] = handle\n        end\n    end\n    xml = [[\n        <ui closeable="false" resizeable="false" activate="false">\n            <label text="30:00" style="* {background-color: #F00; color: #FFF; font-size: 32px; font-weight: bold; padding: 4px; border-radius: 4px;}" id="10"/>>\n        </ui>\n    ]]\n    ui = simUI.create(xml)\n    simUI.setPosition(ui, 0,0, true)\nend\n  \nfunction sysCall_actuation()\n    scoreresult1=sim.readProximitySensor(socoresensors[1])\n    scoreresult2=sim.readProximitySensor(socoresensors[2])\n    for i = 0, 5 do\n        result=sim.readProximitySensor(sensors[i+1])\n        if(result>0)then\n            for i = 1,8 do\n                sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n                sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n                sim.setObjectPosition(ball, -1, randomNumber())\n            end\n        end\n    end\n    if(scoreresult1>0) then\n        regress(0)\n        score2 = score2+1\n    end\n    if(scoreresult2>0)then\n        regress(2)\n        score1 = score1+1\n    end\n    for i = 1, 4 do\n        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)\n    end \n    pink = scoreboard(score1)\n    blue = scoreboard(score2)\n    Toclear()\n    for i = 1, 2 do\n        Number(i,pink[i],1)\n        --Number(i,0)\n        Number(i+2,blue[i],2)\n    end\n    if count > 0 then\n        count = count - 1\n        local minutes = math.floor(count / 60)\n        local seconds = count % 60\n        local timeStr = string.format("%d:%02d", minutes, seconds)\n        simUI.setLabelText(ui, 10, timeStr)\n    else\n        sim.stopSimulation()\n    end\nend\nfunction sysCall_cleanup()\n    Toclear()\nend \n 將計時與現實時間吻合 \n local joints = {{},{},{},{}}\nlocal sensors = {{},{},{},{},{},{}}\nlocal socoresensors = {{},{}}\nlocal angle = {0,0,0,0}\nlocal initPosition = {}\nlocal initOrientation = {}\nlocal BubbleRobs = {}\nlocal handles = {{},{},{},{}}\nlocal serialNumber = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\',\'g\'}\nlocal colors = {{1,0.09,1},{0,0,1},{0,1,1}}\nlocal specialNumbers = {{2, 3},{1,2,4,5,7},{1,2,3,4,7},{2,3,6,7},{1,3,4,6,7},{1,3,4,5,6,7},{1,2,3,6},{1,2,3,4,5,6,7},{1,2,3,4,6,7}}\nspecialNumbers[0] = {1,2,3,4,5,6}\nfunction Number(displayNumber,ser,color)\n    for i = 1, 7 do\n        for j = 1, #specialNumbers[ser] do\n            if i == specialNumbers[ser][j] then\n                sim.setShapeColor(handles[displayNumber][i], nil, sim.colorcomponent_ambient_diffuse, colors[color])\n                break\n            end\n        end\n    end\nend\nfunction scoreboard(number)\n    local numberString = tostring(number)\n    if #numberString < 2 then\n        numberString = \'0\' .. numberString\n    end\n    local tensDigit = tonumber(numberString:sub(1, 1))\n    local onesDigit = tonumber(numberString:sub(2, 2))\n    return{tensDigit,onesDigit}\nend\nfunction Toclear()\n    for i = 1, 7 do\n        for x = 1, 4 do\n            handle = handles[x][i]\n            sim.setShapeColor(handle, nil, sim.colorcomponent_ambient_diffuse, colors[3])\n        end\n    end\nend\nfunction randomNumber()\n    math.randomseed(os.time())\n    return {tonumber(math.random(-1, 1) .. \'.\' .. math.random(0,9)),tonumber(0 .. \'.\' .. math.random(0,9)),0.2}\nend\nfunction regress(team)\n    --sim.pauseSimulation()\n    for i = 1,8 do\n        sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n        sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n    end\n    sim.setObjectPosition(ball, -1, randomNumber())\n    angle[team+1] = angle[team+1] + 1 \n    if angle[team+1] == 10  then\n        angle[team+1] = 0 \n        angle[team+2] = angle[team+2] + 1\n    end\nend\nfunction sysCall_init()\n    count = 300\n    score1 = 0\n    score2 = 0 \n    timer = 0\n    deltaTime = sim.getSimulationTimeStep()\n    print(deltaTime)\n    ball = sim.getObject(\'/Capsule\')\n    for i = 1, 4 do\n        joint = sim.getObject(\'/box/joint\' .. i)\n        joints[i] = joint\n    end\n    for i = 0, 5 do\n        sensor =  sim.getObject(\'/Proximity_sensor[\' .. i ..\']\')\n        sensors[i+1] = sensor\n    end\n    for i = 0, 1 do\n        socoresensor =  sim.getObject(\'/Shape[0]/Proximity_sensor[\' .. i ..\']\')\n        socoresensors[i+1] = socoresensor\n        \n    end\n    for i = 1,8 do\n        BubbleRob = sim.getObject(\'/Shape[\'..i+2 .. \']\')\n        BubbleRobs[i] = BubbleRob\n        initPosition[i] = sim.getObjectPosition(BubbleRob, -1)\n        initOrientation[i] = sim.getObjectOrientation(BubbleRob, -1)\n    end\n    for i = 1, 7 do\n        for x = 1, 4 do\n            ii = tostring(x) .. serialNumber[i]\n            local handle = sim.getObjectHandle("/scoreboard/".. ii )\n            handles[x][i] = handle\n        end\n    end\n    xml = [[\n        <ui closeable="false" resizeable="false" activate="false">\n            <label text="5:00" style="* {background-color: #F00; color: #FFF; font-size: 32px; font-weight: bold; padding: 4px; border-radius: 4px;}" id="10"/>>\n        </ui>\n    ]]\n    ui = simUI.create(xml)\n    simUI.setPosition(ui, 0,0, true)\nend\n  \nfunction sysCall_actuation()\n    timer = timer + deltaTime\n    scoreresult1=sim.readProximitySensor(socoresensors[1])\n    scoreresult2=sim.readProximitySensor(socoresensors[2])\n    for i = 0, 5 do\n        result=sim.readProximitySensor(sensors[i+1])\n        if(result>0)then\n            for i = 1,8 do\n                sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n                sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n                sim.setObjectPosition(ball, -1, randomNumber())\n            end\n        end\n    end\n    if(scoreresult1>0) then\n        regress(0)\n        score2 = score2+1\n    end\n    if(scoreresult2>0)then\n        regress(2)\n        score1 = score1+1\n    end\n    for i = 1, 4 do\n        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)\n    end \n    pink = scoreboard(score1)\n    blue = scoreboard(score2)\n    Toclear()\n    for i = 1, 2 do\n        Number(i,pink[i],1)\n        --Number(i,0)\n        Number(i+2,blue[i],2)\n    end\n    if count > 0 then\n        if timer >= 1 then\n            timer = 0\n            count = count - 1\n            local minutes = math.floor(count / 60)\n            local seconds = count % 60\n            local timeStr = string.format("%d:%02d", minutes, seconds)\n            simUI.setLabelText(ui, 10, timeStr)\n        end\n    else\n        sim.stopSimulation()\n    end\nend\nfunction sysCall_cleanup()\n    Toclear()\nend \n 加入計時板 \n local joints = {{},{},{},{}}\nlocal sensors = {{},{},{},{},{},{}}\nlocal socoresensors = {{},{}}\nlocal angle = {0,0,0,0}\nlocal initPosition = {}\nlocal initOrientation = {}\nlocal BubbleRobs = {}\nlocal handles = {{},{},{},{}}\nlocal timehandles = {{},{},{},{}}\nlocal serialNumber = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\',\'g\'}\nlocal colors = {{1,0.09,1},{0,0,1},{0,1,1},{0,0,0}}\nlocal specialNumbers = {{2, 3},{1,2,4,5,7},{1,2,3,4,7},{2,3,6,7},{1,3,4,6,7},{1,3,4,5,6,7},{1,2,3,6},{1,2,3,4,5,6,7},{1,2,3,4,6,7}}\nspecialNumbers[0] = {1,2,3,4,5,6}\nlocal timesseconds = {0,0}\nlocal timesminutes = {0,5}\nfunction Number(displayNumber,ser,color)\n    for i = 1, 7 do\n        for j = 1, #specialNumbers[ser] do\n            if i == specialNumbers[ser][j] then\n                sim.setShapeColor(handles[displayNumber][i], nil, sim.colorcomponent_ambient_diffuse, colors[color])\n                break\n            end\n        end\n    end\nend\nfunction timeNumber(displayNumber,ser)\n    for i = 1, 7 do\n        for j = 1, #specialNumbers[ser] do\n            if i == specialNumbers[ser][j] then\n                sim.setShapeColor(timehandles[displayNumber][i], nil, sim.colorcomponent_ambient_diffuse, colors[4])\n                break\n            end\n        end\n    end\nend\nfunction scoreboard(number)\n    local numberString = tostring(number)\n    if #numberString < 2 then\n        numberString = \'0\' .. numberString\n    end\n    local tensDigit = tonumber(numberString:sub(1, 1))\n    local onesDigit = tonumber(numberString:sub(2, 2))\n    return{tensDigit,onesDigit}\nend\nfunction Toclear()\n    for i = 1, 7 do\n        for x = 1, 4 do\n            handle = handles[x][i]\n            sim.setShapeColor(handle, nil, sim.colorcomponent_ambient_diffuse, colors[3])\n            timehandle = timehandles[x][i]\n            sim.setShapeColor(timehandle, nil, sim.colorcomponent_ambient_diffuse, colors[3])\n        end\n    end\nend\nfunction randomNumber()\n    math.randomseed(os.time())\n    return {tonumber(math.random(-1, 1) .. \'.\' .. math.random(0,9)),tonumber(0 .. \'.\' .. math.random(0,9)),0.2}\nend\nfunction regress(team)\n    --sim.pauseSimulation()\n    for i = 1,8 do\n        sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n        sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n    end\n    sim.setObjectPosition(ball, -1, randomNumber())\n    angle[team+1] = angle[team+1] + 1 \n    if angle[team+1] == 10  then\n        angle[team+1] = 0 \n        angle[team+2] = angle[team+2] + 1\n    end\nend\nfunction sysCall_init()\n    count = 300\n    score1 = 0\n    score2 = 0 \n    timer = 0\n    deltaTime = sim.getSimulationTimeStep()\n    print(deltaTime)\n    ball = sim.getObject(\'/Capsule\')\n    for i = 1, 4 do\n        joint = sim.getObject(\'/box/joint\' .. i)\n        joints[i] = joint\n    end\n    for i = 0, 5 do\n        sensor =  sim.getObject(\'/Proximity_sensor[\' .. i ..\']\')\n        sensors[i+1] = sensor\n    end\n    for i = 0, 1 do\n        socoresensor =  sim.getObject(\'/Shape[0]/Proximity_sensor[\' .. i ..\']\')\n        socoresensors[i+1] = socoresensor\n        \n    end\n    for i = 1,8 do\n        BubbleRob = sim.getObject(\'/Shape[\'..i+2 .. \']\')\n        BubbleRobs[i] = BubbleRob\n        initPosition[i] = sim.getObjectPosition(BubbleRob, -1)\n        initOrientation[i] = sim.getObjectOrientation(BubbleRob, -1)\n    end\n    for i = 1, 7 do\n        for x = 1, 4 do\n            ii = tostring(x) .. serialNumber[i]\n            local handle = sim.getObjectHandle("/scoreboard/".. ii )\n            handles[x][i] = handle\n        end\n    end\n    for i = 1, 7 do\n        for x = 1, 4 do\n            ii = tostring(x) .. serialNumber[i]\n            local timehandle = sim.getObjectHandle("/time/".. ii )\n            timehandles[x][i] = timehandle\n        end\n    end\nend\n  \nfunction sysCall_actuation()\n    timer = timer + deltaTime\n    scoreresult1=sim.readProximitySensor(socoresensors[1])\n    scoreresult2=sim.readProximitySensor(socoresensors[2])\n    for i = 0, 5 do\n        result=sim.readProximitySensor(sensors[i+1])\n        if(result>0)then\n            for i = 1,8 do\n                sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n                sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n                sim.setObjectPosition(ball, -1, randomNumber())\n            end\n        end\n    end\n    if(scoreresult1>0) then\n        regress(0)\n        score2 = score2+1\n    end\n    if(scoreresult2>0)then\n        regress(2)\n        score1 = score1+1\n    end\n    for i = 1, 4 do\n        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)\n    end \n    pink = scoreboard(score1)\n    blue = scoreboard(score2)\n    Toclear()\n    for i = 1, 2 do\n        Number(i,pink[i],1)\n        --Number(i,0)\n        Number(i+2,blue[i],2)\n    end\n    \n    if count > 0 then\n        if timer >= 1 then\n            timer = 0\n            count = count - 1\n            local minutes = math.floor(count / 60)\n            local seconds = count % 60\n            local timeStr = string.format("%d:%02d", minutes, seconds)\n            timesseconds = scoreboard(seconds)\n            timesminutes = scoreboard(minutes)\n            \n        end\n    else\n        sim.stopSimulation()\n    end\n    for i = 1,2 do\n            timeNumber(i,timesminutes[i])\n            timeNumber(i+2,timesseconds[i])\n    end\nend\nfunction sysCall_cleanup()\n    Toclear()\nend \n 添加計時器閃爍的dot \n local joints = {{},{},{},{}}\nlocal sensors = {{},{},{},{},{},{}}\nlocal socoresensors = {{},{}}\nlocal angle = {0,0,0,0}\nlocal initPosition = {}\nlocal initOrientation = {}\nlocal BubbleRobs = {}\nlocal handles = {{},{},{},{}}\nlocal timehandles = {{},{},{},{}}\nlocal serialNumber = {\'a\',\'b\',\'c\',\'d\',\'e\',\'f\',\'g\'}\nlocal colors = {{1,0.09,1},{0,0,1},{0,1,1},{0,0,0}}\nlocal specialNumbers = {{2, 3},{1,2,4,5,7},{1,2,3,4,7},{2,3,6,7},{1,3,4,6,7},{1,3,4,5,6,7},{1,2,3,6},{1,2,3,4,5,6,7},{1,2,3,4,6,7}}\nspecialNumbers[0] = {1,2,3,4,5,6}\nlocal timesseconds = {0,0}\nlocal timesminutes = {0,5}\nlocal dots = {{},{},{},{}}\nlocal dottime = 1\nfunction Number(displayNumber,ser,color)\n    for i = 1, 7 do\n        for j = 1, #specialNumbers[ser] do\n            if i == specialNumbers[ser][j] then\n                sim.setShapeColor(handles[displayNumber][i], nil, sim.colorcomponent_ambient_diffuse, colors[color])\n                break\n            end\n        end\n    end\nend\nfunction timeNumber(displayNumber,ser)\n    for i = 1, 7 do\n        for j = 1, #specialNumbers[ser] do\n            if i == specialNumbers[ser][j] then\n                sim.setShapeColor(timehandles[displayNumber][i], nil, sim.colorcomponent_ambient_diffuse, colors[4])\n                break\n            end\n        end\n    end\nend\nfunction scoreboard(number)\n    local numberString = tostring(number)\n    if #numberString < 2 then\n        numberString = \'0\' .. numberString\n    end\n    local tensDigit = tonumber(numberString:sub(1, 1))\n    local onesDigit = tonumber(numberString:sub(2, 2))\n    return{tensDigit,onesDigit}\nend\nfunction dotcolor(color)\n    for i = 1,2 do \n        dot = dots[i]  \n        sim.setShapeColor(dot, nil, sim.colorcomponent_ambient_diffuse, colors[color])\n    end \nend\nfunction Toclear()\n    for i = 1, 7 do\n        for x = 1, 4 do\n            handle = handles[x][i]\n            sim.setShapeColor(handle, nil, sim.colorcomponent_ambient_diffuse, colors[3])\n            timehandle = timehandles[x][i]\n            sim.setShapeColor(timehandle, nil, sim.colorcomponent_ambient_diffuse, colors[3])\n        end\n    end\nend\nfunction randomNumber()\n    math.randomseed(os.time())\n    return {tonumber(math.random(-1, 1) .. \'.\' .. math.random(0,9)),tonumber(0 .. \'.\' .. math.random(0,9)),0.2}\nend\nfunction regress(team)\n    --sim.pauseSimulation()\n    for i = 1,8 do\n        sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n        sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n    end\n    sim.setObjectPosition(ball, -1, randomNumber())\n    angle[team+1] = angle[team+1] + 1 \n    if angle[team+1] == 10  then\n        angle[team+1] = 0 \n        angle[team+2] = angle[team+2] + 1\n    end\nend\nfunction sysCall_init()\n    count = 300\n    score1 = 0\n    score2 = 0 \n    timer = 0\n    deltaTime = sim.getSimulationTimeStep()\n    print(deltaTime)\n    ball = sim.getObject(\'/Capsule\')\n    for i = 1, 4 do\n        joint = sim.getObject(\'/box/joint\' .. i)\n        joints[i] = joint\n    end\n    for i = 0, 5 do\n        sensor =  sim.getObject(\'/Proximity_sensor[\' .. i ..\']\')\n        sensors[i+1] = sensor\n    end\n    for i = 0, 1 do\n        socoresensor =  sim.getObject(\'/Shape[0]/Proximity_sensor[\' .. i ..\']\')\n        socoresensors[i+1] = socoresensor\n        \n    end\n    for i = 1,8 do\n        BubbleRob = sim.getObject(\'/Shape[\'..i+2 .. \']\')\n        BubbleRobs[i] = BubbleRob\n        initPosition[i] = sim.getObjectPosition(BubbleRob, -1)\n        initOrientation[i] = sim.getObjectOrientation(BubbleRob, -1)\n    end\n    for i = 1, 7 do\n        for x = 1, 4 do\n            ii = tostring(x) .. serialNumber[i]\n            local handle = sim.getObjectHandle("/scoreboard/".. ii )\n            handles[x][i] = handle\n        end\n    end\n    for i = 1, 7 do\n        for x = 1, 4 do\n            ii = tostring(x) .. serialNumber[i]\n            local timehandle = sim.getObjectHandle("/time/".. ii )\n            timehandles[x][i] = timehandle\n        end\n    end\n    for x = 0, 1 do\n            local dot = sim.getObjectHandle("/dot[".. x ..\']\')\n            dots[x+1] = dot\n    end\nend\n  \nfunction sysCall_actuation()\n    timer = timer + deltaTime\n    scoreresult1=sim.readProximitySensor(socoresensors[1])\n    scoreresult2=sim.readProximitySensor(socoresensors[2])\n    for i = 0, 5 do\n        result=sim.readProximitySensor(sensors[i+1])\n        if(result>0)then\n            for i = 1,8 do\n                sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])\n                sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])\n                sim.setObjectPosition(ball, -1, randomNumber())\n            end\n        end\n    end\n    if(scoreresult1>0) then\n        regress(0)\n        score2 = score2+1\n    end\n    if(scoreresult2>0)then\n        regress(2)\n        score1 = score1+1\n    end\n    for i = 1, 4 do\n        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)\n    end \n    pink = scoreboard(score1)\n    blue = scoreboard(score2)\n    Toclear()\n    for i = 1, 2 do\n        Number(i,pink[i],1)\n        --Number(i,0)\n        Number(i+2,blue[i],2)\n    end\n    \n    if count > 0 then\n        if timer >= 1 then\n            timer = 0\n            count = count - 1\n            local minutes = math.floor(count / 60)\n            local seconds = count % 60\n            local timeStr = string.format("%d:%02d", minutes, seconds)\n            timesseconds = scoreboard(seconds)\n            timesminutes = scoreboard(minutes)\n            dottime = dottime+1\n        end\n        if  dottime >= 2 then\n            dottime = 0 \n        end\n    else\n        sim.stopSimulation()\n    end\n    for i = 1,2 do\n            timeNumber(i,timesminutes[i])\n            timeNumber(i+2,timesseconds[i])\n    end\n    dotcolor(dottime+3)\nend\nfunction sysCall_cleanup()\n    Toclear()\n    dotcolor(3)\nend \n', 'tags': '', 'url': '程式.html'}, {'title': '操控球員', 'text': "初版 \n # pip install pyzmq cbor keyboard\n#from zmqRemoteApi import RemoteAPIClient\nfrom zmqRemoteApi_IPv6 import RemoteAPIClient\nimport keyboard\nclient = RemoteAPIClient('127.0.0.1', 23000)\n\nprint('Program started')\nsim = client.getObject('sim')\nsim.startSimulation()\nprint('Simulation started')\n\ncar = 4\ndef setBubbleRobVelocity(leftfrontWheelVelocity, rightfrontWheelVelocity,leftbackWheelVelocity,rightbackWheelVelocity):\n    leftfrontMotor = sim.getObject('/Shape['+str(car)+']/LF')\n    rightfrontMotor = sim.getObject('/Shape['+str(car)+']/RF')\n    leftbackMotor = sim.getObject('/Shape['+str(car)+']/LB')\n    rightbackMotor = sim.getObject('/Shape['+str(car)+']/RB')\n    \n    \n    sim.setJointTargetVelocity(leftfrontMotor, leftfrontWheelVelocity)\n    sim.setJointTargetVelocity(rightfrontMotor, rightfrontWheelVelocity) \n    sim.setJointTargetVelocity(leftbackMotor, leftbackWheelVelocity)\n    sim.setJointTargetVelocity(rightbackMotor, rightbackWheelVelocity)\n\n'''\n# Example usage 1:\nsetBubbleRobVelocity(1.0, 1.0)\ntime.sleep(2)\nsetBubbleRobVelocity(0.0, 0.0)\n'''\n# use keyborad to move BubbleRob\nv  = 10.0\nwhile True:\n    if keyboard.is_pressed('w'):\n        setBubbleRobVelocity(v, v,v, v)\n    elif keyboard.is_pressed('s'):\n        setBubbleRobVelocity(-v, -v,-v, -v)\n    elif keyboard.is_pressed('a'):\n        setBubbleRobVelocity(-v, v,-v, v)\n    elif keyboard.is_pressed('d'):\n        setBubbleRobVelocity(v, -v,v, -v)\n    elif keyboard.is_pressed('q'):\n        # stop simulation\n        sim.stopSimulation()\n    else:\n        setBubbleRobVelocity(0.0, 0.0,0.0, 0.0)\n\n\n\n\n \n", 'tags': '', 'url': '操控球員.html'}, {'title': 'note', 'text': '*在CoppeliaSim中，「proximity sensors」和「vision sensors」是兩種不同的感測器類型，具有不同的功能和用途。 \n proximity sensors(近距離感應器)->用於檢測物體之間的距離或接近物體的存在 \n vision sensors(視覺感應器)->用於模擬視覺感知能力，可以捕捉和處理場景中的圖像或影像 \n *Tkinter是Python的標準GUI套件，它提供了一組工具和函式庫，使您能夠創建視窗、按鈕、文本框等GUI元件。 \n *CoppeliaSim中提供了多種類型的joints（關節）物件，用於模擬機械結構的運動 。 以下是CoppeliaSim中可用的常見關節物件類型的總結： \n 1.Revolute joint（旋轉關節）：允許物體在一個 軸向上 進行 旋轉運動 ，類似於旋轉軸承或旋轉門鉸鏈。 \n 2.Prismatic joint（平移關節）：允許物體在一個 軸向上 進行 直線運動 ，類似於滑動門或平移台。 \n 3.Spherical joint（球形關節）：允許物體在三個 軸向上 進行 旋轉運動 ，類似於球形關節或肩關節。 \n 4.Planar joint（平面關節）：允許物體在 二維平面 上進行運動，類似於平面鏈條或二維平移機構。 \n 5.Cylinder joint（圓柱關節）：允許物體在 圓柱形表面 上進行運動，類似於滾筒或圓柱體運動。 \n 6.Screw joint（螺旋關節）： 結合旋轉和平移運動 的關節，類似於螺旋運動或螺旋傳動結構。 \n * CoppeliaSim（以前稱為V-REP）是由Coppelia Robotics開發的機器人仿真軟體，提供了一個強大的仿真環境和多種應用程式介面，包括Python。 CoppeliaSim本身並不是直接使用Python編寫的套件，而是使用C++開發的。 \n 在CoppeliaSim中，Python被用作其中一種主要的編寫程序語言，可以使用Python API來控制和操作仿真場景中的物體、機器人和傳感器等元素。 \n CoppeliaSim的Python API允許您使用Python編寫程序，通過對場景中的物體應用變換、設置物體屬性、控制運動和模擬等操作來實現各種仿真目的。 \n 您可以使用Python API進行運動控制、感測模擬、路徑規劃、視覺處理等應用，並與其他Python庫和工具集成，以擴展仿真功能。 \n (因此，可以說CoppeliaSim套件是採用Python編寫的，並且提供了Python API供開發者使用。這使得使用Python在CoppeliaSim中進行機器人仿真和控制變得更加方便和靈活) \n *CoppeliaSim 中的 proximity sensor（近距離傳感器）可以模擬 ultrasonic（超聲波）或 infrared（紅外線）感測器 proximity sensor（ 近距離 傳感器）-> 用於檢測物體之間的距離或接近物體的存在， 是基於仿真模型和參數設定的，用於模擬真實世界的感測器行為 \n *每一個 CoppeliaSim 場景不一定都有 Layers(圖層)、child script(物件上附加的Lua腳本)、Pages(頁面)，皆並不是場景必備的元素。 \n *CoppeliaSim場景中，如果要變更物體的orientation（方向），可以使用Position Dialog（位置對話框） Position Dialog（位置對話框）->不僅限於變更物體的方向，還可以調整物體的位置和尺寸等屬性 \n *當利用 zmqRemoteAPI 控制場景物件時, 只能使用 Lua 進行。  (zmqRemoteAPI僅支持Lua腳本，並不支持使用其他語言，如Python，進行控制) \n * Legacy Python remote API 因為其效能無法與 zmqRemoteAPI 比較, 因此隨後的 remoteAPI 都將採用 zmq 的方式進行控制, 利用 Python 進行控制過程, 必須要能呈現不同改版的差異 \n * CoppeliaSim 的本體是採用  C++ 與 Qt 編寫 , 並利用 Lua 來進行彈性設定與功能延伸, 將 Lua 寫在 .ttt 或 .ttm 中的好處是容易打包, 但在改版過程則沒有文字檔格式的改版資料 \n', 'tags': '', 'url': 'note.html'}, {'title': '快捷鍵', 'text': '當焦點在  scene hierarchy \xa0或\xa0 page 上時 \n \n CTRL+O：打開場景 \n CTRL+N：打開新場景 \n CTRL+S：保存場景 \n CTRL+W：關閉場景 \n CTRL+Q：退出應用程序 \n CTRL+<空格>：開始/停止模擬 \n CTRL+E：在 (1) 正常、(2) 對象平移和 (3) 對象旋轉鼠標模式之間切換 \n CTRL+D：打開對象屬性對話框 \n CTRL+G：打開計算模塊對話框 \n CTRL+B：調整視圖以適合所選對象，如果沒有選擇對象則調整整個場景。 (* 重點需要放在一個視圖上) \n CTRL+ALT+C：將焦點設置在 Lua指令窗上 \n CTRL+L：清除狀態欄（當焦點在 Lua 指令窗上時） \n', 'tags': '', 'url': '快捷鍵.html'}, {'title': '連線說明', 'text': 'zmq連線設定(41023151) \n \n 1.將防火牆關閉(三個都關) \n \n 2.點進階設定 \n \n 3.組長點輸入、組員點輸出 \n \n 4.點新增規則，然後連接埠，規則選TCP，設定特定連接埠為23000-23050 \n \n 5.允許連線 \n 6.設定名稱 \n 7.設定規定的IPV6位置 \n \n 8.將各組的zmq打開，zmq以及CoppeliaSim(4.5.1)要是可以支援IPv6的版本 \n 版本錯誤可以從  https://mde.tw/cd2023/content/pj3.html  下載 \n \n 9.接著打上對應的組長IPv6位置並連線 \n 10.在瀏覽器搜索  http://[組長IP]:23020  觀看組長場景及對戰 \n \n \n', 'tags': '', 'url': '連線說明.html'}, {'title': '連線主機', 'text': '\n \n \n \n', 'tags': '', 'url': '連線主機.html'}]};