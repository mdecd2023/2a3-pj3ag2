<h1>About</h1>
<p>成員:41023106、41023113、41023125、41023153、<span>41023103、41023116、41023132、41023151</span></p>
<p>3ag2倉儲: <a href="https://github.com/mdecd2023/2a2-pj3ag2.git">https://github.com/mdecd2023/2a2-pj3ag2.git</a> </p>
<p></p>
<p>3ag2網站: <a href="https://mdecd2023.github.io/2a2-pj3ag2">https://mdecd2023.github.io/2a2-pj3ag2</a>  </p>
<p></p>
<div id="gtx-trans" style="position: absolute; left: -30px; top: 149.475px;">
<div class="gtx-trans-icon"></div>
</div>
<h1>pj3</h1>
<p></p>
<p><strong>分配表</strong></p>
<p>1.球場繪製:41023106</p>
<p>2.球員繪製、感測器建立':4102313</p>
<p>3.記分板繪製:41023153</p>
<p>4.自動控制程式:41023125</p>
<p></p>
<p><strong>場景模擬</strong></p>
<p><img alt="" height="579" src="/images/螢幕擷取畫面 2023-05-22 105450.png" width="872"/></p>
<p><a href="/downloads/總和球場.ttt">/downloads/總和球場.ttt</a></p>
<p></p>
<p><a href="/downloads/car.ttt">球員場景建立</a></p>
<p>使用onshape繪製球員，後匯入Coppeliasim進行爆炸拆件，拆件後加入joint並且將物件改為實體。</p>
<p>圖檔匯入<span>Coppeliasim步驟: <span style="background-color: #ffff00;">File-Import-Mseh</span>-選擇圖檔匯入</span></p>
<p><span>爆炸拆件:右鍵點選本體-<span style="background-color: #ffff00;">Edit-Grouping/Merging-Divide seleceted shapes</span></span></p>
<p>將物件改為實體:<span style="background-color: #ffff00;">點選本體旁圖示-Show dynamic properties dialog-勾選Body is respondable以及Body is dynamic</span></p>
<p><span style="background-color: #ffffff;">加入joint:滑鼠右鍵-<span style="background-color: #ffff00;">Add-Joint-Revolute</span></span></p>
<p><img alt="" height="540" src="/images/球員.png" width="960"/></p>
<p><strong>做動影片</strong> <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/n2OoUsJiTJQ" title="YouTube video player" width="560"></iframe></p>
<p><strong>開會紀錄:</strong></p>
<p>討論分工及場景建置</p>
<p>協同工作並一起解決問題。</p>
<p>由於尺寸錯誤，因此縮小比例製作了第二版。</p>
<p><a href="/downloads/CAR2.ttt">CAR2.ttt</a></p>
<p><img alt="" height="551" src="/images/球員2.png" width="980"/></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p><a href="/downloads/1.ttt">/downloads/1.ttt</a></p>
<p><strong>計分器</strong></p>
<p><img alt="" height="379" src="/images/螢幕擷取畫面 2023-05-22 092654.png" width="790"/></p>
<p><img alt="" height="468" src="/images/螢幕擷取畫面 2023-05-22 093018.png" width="921"/></p>
<p><a href="/downloads/計分桿.ttt">/downloads/計分.ttt</a></p>
<p><strong><span style="background-color: #ffff00;">球場</span></strong></p>
<p><a href="/downloads/pj3球場.SLDPRT">/downloads/pj3球場.SLDPRT</a></p>
<p><a href="/downloads/pj3球場.STL">/downloads/pj3球場.STL</a></p>
<p><img alt="" height="405" src="/images/螢幕擷取畫面 2023-05-22 105718.png" width="720"/></p>
<p></p>
<p><a href="/downloads/pj3球場.SLDPRT"></a></p>
<p><strong><span style="background-color: #ffff00;">改版</span></strong></p>
<p><a href="/downloads/pj3球場v2.STL">/downloads/pj3球場v2.STL</a></p>
<p><a href="/downloads/pj3球場v2.SLDPRT">/downloads/pj3球場v2.SLDPRT</a> </p>
<p></p>
<p><img alt="" height="430" src="/images/螢幕擷取畫面 2023-05-22 101830.png" width="725"/></p>
<p><a href="/downloads/球場.ttt">/downloads/球場.ttt</a></p>
<p><a href="/downloads/pj3球場v2.SLDPRT"></a></p>
<h1>程式</h1>
<p>記分板測試</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">local joints = {{},{},{},{}}
local angle = {0,0,0,0}
function sysCall_init()
    -- do some initialization here
      for i = 1, 4 do
        joint = sim.getObject('/joint' .. i)
        joints[i] = joint
        --print(joints)
    end
end

function sysCall_actuation()
    -- put your actuation code here
    for i = 1, 4 do
    sim.setJointTargetPosition(joints[i], angle[i])
    a = angle[i]
    angle[i] = a + 36
    end 
    
    
end

function sysCall_sensing()
    -- put your sensing code here
    --
end

function sysCall_cleanup()
    -- do some clean-up here
end

-- See the user manual or the available code snippets for additional callback functions and details
</pre>
<p></p>
<p>記分板連動</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">local joints = {{},{},{},{}}
local sensors = {{},{},{},{},{},{}}
local socoresensors = {{},{}}
local angle = {0,0,0,0}
local initPosition = {}
local initPosition = {}
function regress()
    --sim.pauseSimulation()
    --sim.setObjectPosition(bubbleRobBase, -1, initialBubbleRobPosition)
    --sim.setObjectOrientation(bubbleRobBase, -1, initialBubbleRobOrientation)
    sim.setObjectPosition(ball, -1, initPosition)
    sim.setObjectOrientation(ball, -1, initPosition)
    --sim.setObjectPosition(23, -1, initia)
    --sim.setObjectOrientation(23, -1, initial)
end
function sysCall_init()
    -- do some initialization here
    for i = 1, 4 do
        joint = sim.getObject('/box/joint' .. i)

        joints[i] = joint
        --print(joints)
    end
    for i = 0, 5 do
        sensor =  sim.getObject('/Proximity_sensor[' .. i ..']')
        sensors[i+1] = sensor
    end
    --print(sensors)
    for i = 0, 1 do
        socoresensor =  sim.getObject('/Shape[0]/Proximity_sensor[' .. i ..']')
        socoresensors[i+1] = socoresensor
    end
    ball = sim.getObject('/Capsule')
    initPosition = sim.getObjectPosition(ball, -1)
    initialballOrientation = sim.getObjectOrientation(ball, -1)
    print(initPosition)
end
 
function sysCall_actuation()
    -- put your actuation code here
    
    for i = 0, 5 do
        result=sim.readProximitySensor(sensors[i+1])
        --result=sim.readProximitySensor(sensors[1])
        if(result&gt;0)then
            sim.stopSimulation()
        end
        --print(result)
    end
    scoreresult1=sim.readProximitySensor(socoresensors[1])
    if(scoreresult1&gt;0) then
        angle[3] = angle[3] + 1 
        if angle[3] == 10 then
            angle[3] = 0 
            angle[4] = angle[4] + 1
        end
        --sim.stopSimulation()
        regress()
    end
    scoreresult2=sim.readProximitySensor(socoresensors[2])
    if(scoreresult2&gt;0)then
        angle[1] = angle[1] + 1 
        if angle[1] == 10 then
            angle[1] = 0 
            angle[2] = angle[2] + 1
        end
        --sim.stopSimulation()
        regress()

    end
    for i = 1, 4 do
        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)
        --a = angle[i]
        --angle[i] = a + 1
    end 
 end
</pre>
<p></p>
<p>記分板程式整理</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">local joints = {{},{},{},{}}
local sensors = {{},{},{},{},{},{}}
local socoresensors = {{},{}}
local angle = {0,0,0,0}
local initPosition = {}
local initOrientation = {}
function regress(team)
    --sim.pauseSimulation()
    sim.setObjectPosition(ball, -1, initPosition)
    sim.setObjectOrientation(ball, -1, initOrientation)
    angle[team+1] = angle[team+1] + 1 
    if angle[team+1] == 10 and team == 2 or 0 then
        angle[team+1] = 0 
        angle[team+2] = angle[team+2] + 1
    end
end
function sysCall_init()
    for i = 1, 4 do
        joint = sim.getObject('/box/joint' .. i)
        joints[i] = joint
    end
    for i = 0, 5 do
        sensor =  sim.getObject('/Proximity_sensor[' .. i ..']')
        sensors[i+1] = sensor
    end
    for i = 0, 1 do
        socoresensor =  sim.getObject('/Shape[0]/Proximity_sensor[' .. i ..']')
        socoresensors[i+1] = socoresensor
    end
    ball = sim.getObject('/Capsule')
    initPosition = sim.getObjectPosition(ball, -1)
    initOrientation = sim.getObjectOrientation(ball, -1)
    print(initPosition)
end
  
function sysCall_actuation()
    for i = 0, 5 do
        result=sim.readProximitySensor(sensors[i+1])
        if(result&gt;0)then
        end
    end
    scoreresult1=sim.readProximitySensor(socoresensors[1])
    scoreresult2=sim.readProximitySensor(socoresensors[2])
    if(scoreresult1&gt;0) then
        regress(0)
    end
    if(scoreresult2&gt;0)then
        regress(2)
    end
    for i = 1, 4 do
        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)
    end 
 end</pre>
<p></p>
<p><strong></strong></p>
<p>BubbleRob回歸</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">local joints = {{},{},{},{}}
local sensors = {{},{},{},{},{},{}}
local socoresensors = {{},{}}
local angle = {0,0,0,0}
local initPosition = {}
local initOrientation = {}
local BubbleRobs = {}
function regress(team)
    --sim.pauseSimulation()
    for i = 1,8 do
        sim.setObjectPosition(BubbleRobs[i], -1, initPosition[i])
        sim.setObjectOrientation(BubbleRobs[i], -1, initOrientation[i])
    end
    angle[team+1] = angle[team+1] + 1 
    if angle[team+1] == 10 and team == 2 or 0 then
        angle[team+1] = 0 
        angle[team+2] = angle[team+2] + 1
    end
end
function sysCall_init()
    for i = 1, 4 do
        joint = sim.getObject('/box/joint' .. i)
        joints[i] = joint
    end
    for i = 0, 5 do
        sensor =  sim.getObject('/Proximity_sensor[' .. i ..']')
        sensors[i+1] = sensor
    end
    for i = 0, 1 do
        socoresensor =  sim.getObject('/Shape[0]/Proximity_sensor[' .. i ..']')
        socoresensors[i+1] = socoresensor
        
    end
    --ball = sim.getObject('/Capsule')
    --initPosition = sim.getObjectPosition(ball, -1)
    --initOrientation = sim.getObjectOrientation(ball, -1)
    for i = 1,8 do
        BubbleRob = sim.getObject('/Shape['..i+2 .. ']')
        BubbleRobs[i] = BubbleRob
        initPosition[i] = sim.getObjectPosition(BubbleRob, -1)
        initOrientation[i] = sim.getObjectOrientation(BubbleRob, -1)
    end
    print(initPosition[1])
end
  
function sysCall_actuation()
    for i = 0, 5 do
        result=sim.readProximitySensor(sensors[i+1])
        if(result&gt;0)then
        end
    end
    scoreresult1=sim.readProximitySensor(socoresensors[1])
    scoreresult2=sim.readProximitySensor(socoresensors[2])
    if(scoreresult1&gt;0) then
        regress(0)
    end
    if(scoreresult2&gt;0)then
        regress(2)
    end
    for i = 1, 4 do
        sim.setJointTargetPosition(joints[i], angle[i]*-0.62)
    end 
 end</pre>
<p></p>